## GC (Garbage collection)

- **동적으로 할당된** 메모리 중에서 더 이상 사용되지 않는 메모리를 자동으로 찾아내고 회수하는 프로세스
- 메모리 누수(Memory Leak)를 방지하고 프로그래머의 메모리 관리에 대한 부담을 일부 덜어줌

### 도입 배경

- `C/C++`와 같은 언어는 프로그래머가 수동으로 메모리 할당과 해제를 일일이 해줘야 함
    - 메모리를 할당하고 필요 없어진 뒤에도 해제하지 않거나
    - 해제했던 메모리를 다시 사용하거나
    - 해제했던 메모리를 또 해제하는 등
    
    메모리와 관련된 잦은 실수로 버그 발생
    
- `Java`, `C#`, `Python`, `Javascript`, `Go` 등에서는 GC가 메모리 관리를 대행
    - 프로세스가 한정된 메모리를 효율적으로 사용
    - 개발자가 메모리 문제에서 대해 직접 관리하지 않아 로직에 좀 더 집중

### 단점

- **성능 오버헤드**
    
    주로 객체가 많이 생성되고 소멸되는 상황에서 GC는 효과적이나, 객체의 생성 및 소멸이 잦지 않은 경우에는 가비지 컬렉션에 의해 성능 낭비됨
    
- **Stop The World**
    
    대부분의 가비지 컬렉션 알고리즘은 메모리를 관리하기 위해 실행 중인 프로그램을 일시적으로 중단 → 실시간 시스템이나 특정 응용 프로그램에서 문제 발생
    
- **예측 어려움**
    
    특정 타이밍에 높은 성능이 필요한 응용 프로그램에서 문제 발생할 수 있음
    
- **순간적인 부하**
    
    주기적으로 실행되어 불필요한 객체를 찾아내고 해제하는 작업을 수행 → GC 동작 때 마다 추가적인 CPU 및 메모리 리소스 사용
    

---

## GC 알고리즘

### Reference Counting (참조 카운팅)

- 객체가 참조되는 횟수를 세어서 해당 객체의 메모리를 할당하거나 해제하는 방식
    1. **객체 생성 및 초기화:** 객체가 생성되면 참조 카운트가 1로 초기화
    2. **참조 수 증가:** 다른 객체가 해당 객체를 참조할 때마다 참조 카운트가 1씩 증가
    3. **참조 수 감소:** 객체를 참조하는 모든 참조가 삭제될 때마다 해당 객체의 참조 카운트가 1씩 감소
    4. **참조 카운트가 0인 경우:** 참조 카운트가 0이 되면 해당 객체는 더 이상 필요하지 않다고 판단하고 해당 객체의 메모리를 해제
- 단순하고 직관적이나 **순환 참조**(두 개 이상의 객체가 서로를 참조하는 경우)에 대한 처리가 어려워 메모리 누수의 가능성이 있음

### Stop-and-Copy

- 메모리를 두 부분으로 나누고 한 부분에 있는 객체들을 다른 부분으로 복사하는 방식
    1. **메모리 공간 나누기:** 사용 가능한 메모리 공간을 `From 공간`과 `To 공간` 두 영역으로 분리
    2. **객체 복사:** `From 공간`에 있는 모든 객체들을 `To 공간`으로 복사
    3. **포인터 수정:** 객체가 복사될 때, 해당 객체를 참조하는 모든 포인터들도 업데이트되어 `To 공간`을 가리키게 됨
    4. **공간 교체:** `From 공간`과 `To 공간`의 역할을 교체(`To 공간`이 사용 가능한 메모리로 되고, `From 공간`이 다음 가비지 컬렉션을 위한 새로운 공간이 됨)
- **메모리 단편화**를 최소화할 수 있으나 메모리 사용 효율이 감소하고 객체 복사 오버헤드가 발생

### Mark-and-Sweep

**Mark**와 **Sweep** 두 단계로 나누어 참조 상태를 추적하는 방식

1. **Mark 단계:**
    - **루트 객체 식별:** 가비지 컬렉션이 시작될 때, `루트 객체`(프로그램이 시작될 때부터 접근 가능한 객체로 전역 변수, 스택, 레지스터 등)들을 식별
    - **참조된 객체 표시:** `루트 객체`로부터 출발하여 참조되는 모든 객체를 마킹
2. **Sweep 단계:**
    - **마킹되지 않은 객체 회수:** 모든 객체를 순회하면서 마킹되지 않은 객체는 사용되지 않는 것으로 간주하여 메모리를 해제
    - **마킹 초기화:** 다음 가비지 컬렉션을 위해 마킹된 객체의 표시를 초기화
- **비중앙 집중식**, **비간섭적 알고리즘**으로 효율적이나 **메모리 단편화** 문제가 있음
- 전체 메모리를 검사해야 하므로 큰 힙이나 객체가 많은 상황에서는 일시적으로 중단될 수 있음
    
    → 최신 GC는 주로 세대(generational) 기법을 결합하여 사용
    

### **Generational Collection**

객체를 세대로 나누어 관리하는 방식

1. **새로운 객체 할당:** 대부분의 객체는 `Young Generation`에 할당
2. `Young Generation`**에서 가비지 컬렉션:** 주기적으로 또는 `Young Generation`이 가득 찰 때마다 가비지 컬렉션 수행
3. **생존한 객체 이동:** 가비지 컬렉션 후에 여전히 살아있는 객체들은 `Old Generation`로 이동
4. `Old Generation`**에서 가비지 컬렉션:** `Old Generation`에서는 `Young Generation`에 비해 가비지 컬렉션이 적게 수행됨
- `Young Generation`: 대부분의 객체가 일시적인 수명을 가지므로 빈번한 GC 수행으로 빠르게 객체 회수 가능
- `Old Generation` : 객체의 수명이 상대적으로 길기 때문에 적은 GC 수행으로 오버헤드 감소

---

## 언어별 특징

### GC in Java

[JVM에서 Garbage Collection(GC) 이 일어나는 방식 알아보기](https://kotlinworld.com/340)

[Java Garbage Collection](https://d2.naver.com/helloworld/1329)

### GC in Javascript

[가비지 컬렉션](https://ko.javascript.info/garbage-collection)

[자바스크립트 v8 엔진의 가비지 컬렉션 동작 방식 | 카카오엔터테인먼트 FE 기술블로그](https://fe-developers.kakaoent.com/2022/220519-garbage-collection/)

### GC in Go

[Go 언어의 GC에 대해](https://engineering.linecorp.com/ko/blog/go-gc)

---
