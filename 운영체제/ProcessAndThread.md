# 프로세스와 스레드

## 1. 프로세스란?

**실행 중인 프로그램, 메모리에 적재 된 프로그램**

## 2. 프로세스의 구성

1. **메모리 구조, 프로세스는 각각 독립된 메모리를 할당받는다.**
    
   ![운영체제/ProcessAndThread/Untitled.png](/운영체제/ProcessAndThread/Untitled.png)
    
    **프로세스는 코드, 데이터, 힙, 스택으로 구성된다.**
    
    ![Screenshot_2023-06-28-23-02-15-744_com.miui.notes.png](/운영체제/ProcessAndThread/Screenshot_2023-06-28-23-02-15-744_com.miui.notes.png)
    
    - 스택 : 데이터를 일시적으로 저장하는 영역. 지역변수에 사용하고, 변수가 범위 밖으로 이동하면 공간을 해제한다. 호출한 함수의 반환 주소, 반환 값, 매개변수 등에 사용하고, 함수를 호출할수록 커지고 반환하면 줄어든다. 보통 힙과 인접한 방향으로 점점 커져 스택 포인터와 힙 포인터를 만나면 메모리가 소진되었다는 의미이다.
    - 힙 : 코드 영역과는 별도로 유지되는 자유 영역이다. 동적으로 메모리를 할당하려고 프로그램 실행 중 시스템 호출을 사용했다가 해제하는 방법으로 활용한다. 프로세스의 공유 라이브러리와 동적으로 적재된 모듈이 서로 공유하는데, 동적 메모리 할당이 발생하면 보통 위쪽으로 커진다.
    - 데이터 : 프로그램의 가상 주소 공간이다. 전역변수나 정적변수를 저장하거나 할당하고 실행하기전에 초기화한다.
    - 코드 : 코드는 실행 명령을 포함하는 메모리이거나 목적 파일에 있는 프로그램 영역이다. 프로그램을 시작 할 떄 프로세서가 디스크에서 읽어 실행하는 컴파일한 프로그램을 저장한다. 프로세스로 변경할 수 없고, 읽기 전용이므로 프로그램이 코드 영역을 침범하여 쓰기를 시도하면 오류가 발생해서 프로그램을 종료한다. 코드 영역은 공유할 수 있으므로 자주 실행하는 워드 프로세서, C 컴파일러, 셸 같은 프로그램의 사본 하나는 메모리에 조재한다. 프로세스 2개가 동일한 문서 편집기를 사용하고 데이터 영역이 같더라도 스택 영역은 서로 달라 별개의 프로세스로 인식한다.
    
2. **PCB(Process Control Block)**
    - 프로세스의 관리를 위해 운영체제는 각 프로세스마다 PCB를 두고 해당  프로세스의 정보를 보관한다.
    - 프로세스가 생성되면 프로세스 제어 블록을 생성하고, 프로세스가 실행을 종료하면 해당 프로세스 제어 블록도 삭제한다.
    - PCB에는 다음과 같은 정보가 들어있고 운영체제의 모든 모듈이 이 정보를 읽고 수정할 수 있다.
    
    | 프로세스 식별자 | 각 프로세스의 고유 식별자(숫자, 색인 항목 |
    | --- | --- |
    | 프로세스 상태 | 생성, 준비, 실행, 대기, 중단 등 상태 표시 |
    | 프로그램 카운터(PC) | 프로세스를 실행하는 다음 명령의 주소 표시 |
    | 레지스터 저장 영역 | 누산기, 인덱스 레지스터, 스택 포인터, 범용 레지스터, 조건 코드 등 정보로, 컴퓨터 구조에 따라 수나 형태가 다르다. 인터럽트가 발생하면 프로그램 카운터와 함깨 저장하여 재실행할 때 원래대로 복귀할 수 있게 한다. |
    | 프로세서 스케줄링 정보 | 프로세스의 우선순위, 스케줄링 큐의 포인터, 기타 스케줄 매개변수 |
    | 계정 정보 | 프로세서 사용 시간, 실제 사용 시간, 사용 상한 시간, 계정 번호, 작업이나 프로세스 번호 등 |
    | 입출력 상태 정보,메모리 관리 정보, … | 특별한 입출력 요구 프로세스에 할당된 입출력장치, 열린 파일 리스트 등 / 운영체제가 사용하는 메모리 시스템에 따른 상한, 하한 레지스터, 페이지 테이블이나 세그먼트 테이블 값  |
    

## 3. 프로세스의 종류

| 구분 | 종류 | 설명 |
| --- | --- | --- |
| 역할 | 시스템(커널) 프로세스 | 모든 시스템 메모리와 프로세서의 명령에 엑세스할 수 있는 프로세스이다. 프로세스 실행 순서를 제어하거나 다른 사용자 및 커널(운영체제) 영역을 침범하지 못하게 감시하고, 사용자 프로세스를 생성하는 기능을 한다. |
|  | 사용자 프로세스 | 사용자 코드를 수행하는 프로세스이다. |
| 병행 수행 방법 | 독립 프로세스 | 다른 프로세스에 영향을 주지 않거나 다른 프로세스의 영향을 받지 않으면서 수행하는 병행 프로세스이다. |
|  | 협력 프로세스 | 다른 프로세스에 영향을 주거나 다른 프로세스에서 영향을 받는 병행 프로세스이다. |

## 4. 프로세스의 상태 변화

![Screenshot_2023-06-28-23-40-40-773_com.miui.notes.png](/운영체제/ProcessAndThread/Screenshot_2023-06-28-23-40-40-773_com.miui.notes.png)

- 준비상태 : 메모리에 올라온 상태
- 실행상태 : CPU를 할당 받은 상태
- 대기상태 : I/O 요청, 새로운 자원 요청 등의 문제로 잠시 CPU를 빼앗긴 상태

## 5. 프로세스의 문맥 교환(Context Switching)

인터럽트나 시스템 콜 등으로 실행 중인 프로세스의 제어를 다른 프로세스에게 넘겨 실행 상태가 되도록 하는 것을 프로세스 문맥 교환이라고 한다. 프로세스 문맥 교환이 일어나면 프로세서의 레지스터에 있던 내용을 나중에 사용할 수 있도록 저장한다.

**인터럽트 유형 :** 

- **입출력 인터럽트** : 입출력 동작이 발생했음을 확인하고 이벤트를 기다리는 프로세스를 준비 상태로 바꾼 후 실행할 프로세스를 결정한다.
- **클록 인터럽트** : 현재 실행 중인 프로세스의 할당 시간을 조사하여 실행 중인 프로세스를 준비상태로 바꾸고, 다른 프로세스를 실행 상태로 바꾼다.

문맥 교환은 오버헤드가 큼으로 운영체제를 설계할 때 불필요한 문맥 교환을 줄이는 것으르 주요 목표로 설정한다.

## 6. 프로세스의 관리

1. **프로세스의 구조 :** 프로세스는 실행 중에 프로세스 생성 시스템 콜을 이용하여 새로운 프로세스를 생성할 수 있다. 이때 프로세스 생성 순서를 저장하고 부모-자식 관계를 유지하여 계층적으로 생성한다. 프로세스를 새로 생성하는 프로세스는 부모 프로세스이고, 생성되는 프로세스는 자식 프로세스 또는 서브 프로세스이다. 부모 프로세스를 생성하는 과정을 반복하면서 계층 구조를 형성한다.

1. **프로세스의 생성 :** 운영체제나 응용 프로그램에서 요청을 받아 프로세스를 생성하면, 운영체제는 해당 프로세스에서 프로세스 제어 블록을 만들어 주소 공간을 할당한다. 일괄 처리 환경에서는 준비 큐에 작업이 도착할 때 프로세스를 생성하고, 대화형 환경에서는 새로운 사용자가 로그온 할때 프로세스를 생성한다.
    
    프로세스 생성 시스템 콜 방법이 모든 운영체제에서 동일한 것은 아니다.
    
    - UNIX와 Linux는 `fork()` 시스템 호출을 이용하여 자식 프로세스를 생성하는데, 이때 자식 프로세스는 부모 프로세스의 복제본이 된다. 즉 부모 프로세스의 메모리 구조를 복사하여 자식 프로세스의 메모리 구조로 이용하고 PCB도  프로세스 번호를 제외하고는 그에 상응하게 만들어지기에, 부모 프로세스와 자식 프로세스 모두 PC가 가리키는 곳, 다시 말해 다음에 수행될 위치는 프로그램의 `fork()` 다음 명령이 된다. 만약 자식 프로세스가 부모 프로세스와는 다른 프로그램을 실행시키기를 원한다면 `exec()` 시스템 콜을 이용하여 원하는 프로그램을 실행시킬 수 있다. 이 경우 자식 프로세스는 복제되었던 메모리 구조와 PCB의 내용을 새로운 프로그램의 내용으로 대체하게 된다.(`fork`를 호출한 후 `exec`를 연달아 호출하여 자식 프로세스의 주소 공간을 별도 프로그램 주소 공간으로 덮어쓰는 것이다.)
    - Windows는 `CreatProcess()` 시스템 콜을 이용하여 자식 프로세스를 생성하는데, UNIX나 Linux와 달리 부모 프로세스의 복제가 아닌 처음부터 새로운 프로그램으로 자식 프로세스를 생성한다. 비록 자식 프로세스 생성방식은 운영체제별로 다를지라도 생성된 자식 프로세스의 프로세스 번호가 부모 프로세스에 전달되는 것은 동일하다.
    - 프로세스를 생성할 때 필요한 세부 작업 :
        - 새로운 프로세스에 프로세스 식별자를 할당한다.
        - 프로세스의 모든 구성 요소를 포함할 수 있는 주소 공간과 프로세스 제어 블록 공간을 할당한다.
        - 프로세스 제어 블록을 초기화한다. 프로세스 상태, 프로그램 카운터 등 초기화, 자원 요청, 프로세스 제어 정보(우선순위) 등을 포함한다.
        - 링크를 건다(해당 큐에 삽입한다).

1.  **프로세스의 종료 :** 프로세스가 마지막 명령을 실행하면 종료하여 운영체제에 프로세스의 삭제를 요청한다. 일괄 처리 환경에서는 작업 종료를 의미하는 신호로 인터럽트를 발생하거나 시스템 콜로 중단 명령을 전달하여 프로세스를 종료한다. 대화형 환경에서는 사용자가 로그오프하거나 터미널을 닫으면 프로세스를 종료한다. 이외에도 오류로 프로세스를 종료할 수 있다.
    - `abort` 명령어로도 프로세스를 종료할 수 있다. `abort` 명령어는 종료할 프로세스의 부모 프로세스만 호출하는데, 부모가 아닌 다른 프로세스가 임의로 해당 프로세스를 중단할 수 없기 때문이다. 그리고 자식 프로세스는 종료할 때 자신의 식별자를 부모 프로세스에 전달한다.
    - 유닉스에서는 `exit` 명령어로 프로세스를 종료하고, 부모 프로세스는 `wait` 명령어를 사용하여 자식 프로세스의 종료를 기다린다. `wait` 명령어는 종료한 자식 프로세스의 식별자를 부모 프로세스에 돌려주므르 어떤 자식 프로세스를 종료했는지 알려 준다.
    
    프로세스가 종료되는 다양한 이유의 예 : 
    
    - **정상 종료 :** 프로세스가 운영체제의 서비스를 호출할 때
    - **시간 초과 :** 프로세스가 명시된 전체 시간을 초과하여 실행하거나 명시된 시간을 초과하면서 어떤 이벤트 발생을 기다릴 때
    - **실패** : 파일 검색 실패, 입출력이 명시된 횟수를 초과하여 실패할 때
    - 산술 오류, 보호 오류, 데이터 오류, 메모리 부족, 엑세스 위반 등

## 7. 스레드의 개념

프로세스는 두 가지 특성인 자원과 제어로 구분할 수 있다. 이 중 제어만 분리한 실행 단위를 스레드라고 하는데, 프로세스 하나는 스레드 한 개 이상으로 나눌 수 있다.

![https://gmlwjd9405.github.io/images/os-process-and-thread/multi-thread.png](https://gmlwjd9405.github.io/images/os-process-and-thread/multi-thread.png)

각각의 스레드는 프로그램 카운터(PC), 스택 포인터(SP)등을 비롯한 스레드실행 환경 정보(문맥 정보), 지역 데이터, 스택을 독립적으로 가지면서 코드, 전역 데이터, 힙을 다른 스레드와 공유한다.

![Screenshot_2023-06-29-18-41-44-678_com.miui.notes.png](/운영체제/ProcessAndThread/Screenshot_2023-06-29-18-41-44-678_com.miui.notes.png)

## 8. 스레드 사용의 이점

1. **사용자 응답성 증가** : 응용 프로그램의 일부분을 봉쇄하거나 긴 작업을 수행하더라도 병렬 프로그래밍으로 프로그램을 계속 실행할 수 있어 사용자 응답성이 증가한다. 예를 들어, 다중 스레드를 적용한 웹 브라우저는 스레드 한 개가 파일을 로딩하는 동안 다른 스레드는 사용자와 상호작용 할 수 있다.
2. **프로세스의 자원과 메모리 공유 가능** : 스레드들이 프로세스 자원 하나와 메모리를 공유하므로 응용 프로그램 하나가 동일한 주소 공간에서 스레드를 여러 개 실행하여 시스템 성능을 향상시킬 수 있다.
3. **경제성이 좋음** : 프로세스를 생성하는 것보다 스레드를 생성하여 문맥을 교환하면 오버헤드가 줄어든다.
4. **다중 처리(멀티 프로세싱)로 성능과 효율 향상** : 각 스레드를 여러 프로세서에 병렬로 실행하여 성능과 효율성을 높일 수 있다.

## 9. 멀티 스레드

1. **운영체제는 단일 프로세스에서 단일 스레드 실행이나 멀티 스레드 실행을 지원한다.**

![Untitled](/운영체제/ProcessAndThread/Untitled1.png)

여기서 단일 스레드를 지원하는 운영체제는 프로세스 하나에 스레드 한 개를 실행하는 전통적인 방법으로 아직 스레드 용어가 탄생하기 전이라 개념이 불확실하다. 도스가 대표적인 예이다.

현대 운영체제는 대부분 멀티 스레드이다. 멀티 스레드는 프로그램 하나를 여러 실행 단위로 쪼개어 실행한다는 측면에서 멀티 프로그래과 의미가 비슷하지만 동일 프로세스의 스레드는 자원을 공유하며 커널이 개입하지 않고도 독립적으로 실행할 수 있어 서버에서 많은 요청을 효과적으로 처리할 수 있다.

1. **스레드 제어 블록 (TCB)**

![img.png](/운영체제/ProcessAndThread/img.png)

프로세스가 PCB에 정보를 저장하듯이 스레드도 스레드 제어 블록에 정보를 저장한다. 그런데 프로세스는 스레드를 한 개 이상 가질 수 있으므로, 결국 프로세스 제어 블록은 스레드 제어 블록의 리스트를 가리킨다.

## 10. 스레드의 구현

1. **사용자 수준 스레드**
    
    ![img1.daumcdn.png](/운영체제/ProcessAndThread/img1.daumcdn.png)
    
    - 사용자 수준 스레드는 운영체제가 아닌 응용 프로그램에서 관리되는 스레드이다.
    - 사용자 수준 스레드는 스레드 라이브러리에 의해 관리되며, 운영체제는 스레드의 존재를 알지 못한다.
    - 사용자 수준 스레드는 응용 프로그램의 컨텍스트 스위칭과 스케줄링을 담당한다.
    - 하나의 프로세스 내에 여러 개의 사용자 수준 스레드를 생성할 수 있으며, 각 스레드는 독립적으로 실행된다.
    - 그러나 사용자 수준 스레드가 블로킹(System Call 등으로 인해) 상태에 들어가면, 해당 프로세스의 모든 스레드가 중단될 수 있다.
2. 커널 수준 스레드
    
    ![img1.daumcdn.png](/운영체제/ProcessAndThread/img1.daumcdn1.png)
    
    - 커널 수준 스레드는 운영체제 커널에서 직접 관리되는 스레드이다.
    - 각 스레드에 대해 운영체제는 스레드의 컨텍스트 스위칭과 스케줄링을 수행한다.
    - 커널 수준 스레드는 동시에 실행될 수 있으며, 멀티코어 시스템에서 병렬 처리를 지원할 수 있다.
    - 커널 수준 스레드는 블로킹 상태에 있는 스레드가 있더라도 다른 스레드가 실행될 수 있다.
3. 혼합형 스레드
    
    ![img1.daumcdn.png](/운영체제/ProcessAndThread/img1.daumcdn2.png)
    
    - 혼합형 스레드는 사용자 수준 스레드와 커널 수준 스레드를 혼합하여 사용하는 방식이다.
    - 일반적으로, 각 사용자 수준 ㅅ스레드는 커널 수준 스레드에 매핑된다.
    - 혼합형 스레드 모델은 사용자 수준 스레드와 커널 수준 스레드의 장점을 결합하여 효율적인 스레드 관리를 제공한다.
    - 커널 수준 스레드를 사용하여 병렬 처리와 동시성을 활용하면서, 사용자 수준 스레드를 사용하여 스레드 간의 블로킹 상태에 대한 유연성을 제공할 수 있다.
    - 혼합형 스레드 모델은 여러 스레드 라이브러리와 운영체제에서 지원된다.

## 사용자 수준 스레드와 커널 수준 스레드의 차이점과 사용 이유에 대해

1. 메모리 영역은 크게 user 영역과 kernel 영역으로 나뉜다, 이중모드라고도 하며 한 컴퓨터를 여러 사람이 동시에 사용하는 환경(ex → server) 또는 한 사람이 여러 개의 프로그램을 동시에 사용하는 경우에 한 사람의 고의/실수로 프로그램 전체에 영향을 끼칠 수 있다(ex → (STOP, HALT, RESET ← Assembly lang, 그리고 이러한 명령어를 privileged instructions라고도 한다.) 명령어 등)
2. 그래서 사용자 프로그램은 STOP등의 치명적 명령을 사용 불가하게 user 모드 kernel 모드(priviliged 모드)로 운영체제는 나누게 된다.
3. 그래서 기본적으로 프로그램은 user모드로 동작하다가 privileged instruction이 필요한 경우에 kernel 모드로 동작하게 된다.
4. 중요한것은 모드의 전환엔 오버헤드가 있다는 것.
5. 커널 수준 스레드와 유저 레벨 스레드는 생성 주체가 누구냐에 따라 구분한다.
6. 커널 레벨 쓰레드의 단점은 유저 모드에서 커널 모드로의 전환이 빈번하게 이뤄져 성능 저하가 발생하기 때문에 유저 레벨 스레드를 사용할 수 있다. 유저 레벨 스레드를 사용하면 커널은 스레드의 존재를 모르기 때문에 모드 간의 전환이 없으며 따라서 성능적으로 이득이다.
7. 그렇지만 유저 레벨 스레드는 커널 관점에서 보면 하나의 프로세스이기(스레드) 때문에 한 스레드가 커널에 블로킹되면 프로세스 전체가 블로킹될 수 있다.

- 참조
    - 구현회. 2021. 그림으로 배우는 구조와 원리 운영체제. 개정 3판. 서울 : 한빛아카데미.
    - 김진욱, 이인복. 2023. 운영체제. 초판. 서울 : 한국방송통신대학교 출판문화원.
    - 양희재. 운영체제. 경성대.
