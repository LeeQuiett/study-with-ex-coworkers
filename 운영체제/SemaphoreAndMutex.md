# 세마포어, 뮤텍스(이진 세마포어와 뮤텍스의 차이)

공유메모리를 이용하여 공통된 변수와 버퍼를 공유하는 프로세스는 **독립적으로 수행되면 올바르게 동작**하나 **병행적으로 실행되면 공유 변수의 값이 결과에 영향**을 주어 올바르게 작동하지 않을 수 있습니다.

이와 같이 여러 프로세스가 병행으로 수행되어 발생하는 문제를 해결하는 것을 **프로세스 동기화**라고 하고 **운영체제와 프로그래밍 언어 수준**에서 병행성을 위해 제공하는 기법 중 하나가 **세마포어(semaphores)** 입니다.

이 문서에서는 편의상 프로세스들의 병행 수행을 예로 드나 실제 시스템에서 병행성의 기본 단위는 프로세스가 아닌 쓰레드임을 알아두시길 바랍니다.

**시작하며 관련 있는 중요 용어를 정리하고 가겠습니다.**

|||
| --- | --- |
| 상호 배제(mutual exclusion) | 한 프로세스가 공유 자원을 접근하는 임계영역 코드를 수행하고 있으면 다른 프로세스들은 공유 자원을 접근하는 임계영역 코드를 수행할 수 없다는 조건. |
| 경쟁상태(race condition) | 두개 이상의 프로세스가 공유 자원을 동시에 접근하려는 상태. 최종 수행 결과는 프로세스들의 상대적인 수행 순서에 따라 달라질 수 있다. |
| 임계영역(critical section) | 공유 자원을 접근하는 프로세스 내부의 코드 영역. 다른 프로세스가 이 영역에 있을 때, 이 프로세스 또한 이 영역을 수행할 수 없다. |
| 원자적 연산(atomic operation) | 하나 또는 여러 개의 명령어들로 구성된 함수 또는 액션으로 더 이상 분할할 수 없는 단위. 따라서 다른 어떤 프로세스도 중간 상태를 볼 수 없으며, 연산을 중단 시킬 수 없다. 이 명령어들은 모두 수행되거나 하나도 수행되지 않음이 보장된다. 원자성은 병행 프로세스들에게 고립(isolation)을 보장한다. |

**대표적인 병행성 기법을 정리해 보겠습니다.**

|| |
| --- | --- |
| 세마포어(Semaphore) | 프로세스 간에 시그널(signal)을 주고받기 위해 사용되는 정수 값. 세마포어는 다음 3 가지 원자적인 연산만을 지원한다: initialize, decrement, increment. Decrement 연산은 프로세스를 블록시킬 수 있다. 반면 Increment 연산은 블록되었던 프로세스를 깨울 수 있다. 이 세마포어를 카운팅 세마포어(counting semaphore) 또는 일반 세마포어(general semaphore)라고 한다. |
| 이진 세마포어(Binary Semaphore) | 이 세마포어는 0 또는 1을 값으로 가질 수 있다. |
| 뮤텍스(Mutex) | 이진 세마포어와 유사하다. 차이점은 뮤텍스에 락을 획득(값을 0으로 설정)한 프로세스가 반드시 그 락을 해제(값을 1로 설정)해야 한다는 것이다. |

- 예1)

“counter++”를 어셈블리어로 표현하면 다음과 같습니다.

```java
register1 = counter;

register1 = register1 + 1;

counter = register1;
```

“counter—”는 다음과 같습니다.

```java
register2 = counter;

register2 = register2 - 1;

counter = register2;
```

여기서 register 과 register2 는 CPU 내부 레지스터이며 같은 레지스터일 수 있고 두 문장이 병행으로 수행되면 아래와 같을 수 있습니다.

```java
T0 : 생산자 register1 = counter;      {register1 = 5}
T1 : 생산자 register1 = register1 + 1 {register1 = 6}
T2 : 소비자 register2 = counter;      {register2 = 5}
T3 : 소비자 register2 = register2 - 1 {register2 = 4}
T4 : 생산자 counter = register1;      {counter = 6}
T5 : 소비자 counter = register2;      {counter = 4}
```

- 예2)

변수의 값이 항상 같아야 하는 두 개의 변수 a와 b를 여러 프로세스가 공유한다고 가정하고 다음과 같은 두 개의 프로세스가 있다고 해보겠습니다.

```java
- P1
	a = a + 1;
	b = b + 1;

- P2
	b = b * 2;
	a = a * 2;
```

각 프로세스가 독립적으로 수행되면 일관성이 유지되나 병행으로 수행되면 다음과 같이 일관성이 깨질 수 있습니다.

```java
a = a + 1;
b = b * 2;
b = b + 1;
a = a * 2;
```

이처럼 **고급 프로그래밍 문장이 원자적으로 수행되어도 원하지 않는 결과가 발생할 수 있고 이를 피하기 위한 여러 기법중 하나로 세마포어를 사용**할 수 있습니다.

### 세마포어 연산

* 세마포어 연산은 반드시 원자적으로 구현되어야 합니다.
* 이를 구현하는 방법 중에 하나는 하드웨어나 펌웨어 수준에서 구현하는 것입니다.
* 이 문제의 핵심은 상호 배제이고 즉 한 시점에 오직 하나의 프로세스만이 세마포어 변수를 접근할 수 있어야 합니다.
* 이를 위해 Dekker 알고리즘이나 Peterson알고리즘 등과 같은 소프트웨어적인 기법을 사용할 수 있으나 오버헤드가 큽니다.
* 다른 구현 방법으로 인터럽트 금지 등과 같은 하드웨어 자원을 사용할 수 있습니다.
* 세마포어는 P 연산과 V 연산으로 이루어집니다.

아래는 세마포어 카운트를 1로 가정한 예 입니다.

```java
semaphore sem = 1;  // sem 세마포어를 1로 초기화합니다.

# 프로세스 1
P(sem);  // 공유 자원을 사용하기 전에 P 연산으로 임계 구역에 진입합니다.
{sem -= 1} // p는 감소를 의미, 세마포어를 감소시킵니다.

# 임계 구역 코드

V(sem);  // 공유 자원 사용이 끝나면 sem 세마포어를 반환합니다.
{sem += 1} // v는 증가를 의미 세마포어를 증가시킵니다.

# 프로세스 2
P(sem);  // 프로세스 1이 sem 세마포어를 반환할 때까지 대기합니다.

# 임계 구역 코드

V(sem);  // 공유 자원 사용이 끝나면 sem 세마포어를 반환합니다.

```

---

### 세마포어, 이진 세마포어, 뮤텍스의 차이

- 이진 세마포어는 0이나 1만 가질수 있습니다.
- (비이진)세마포어(counting semaphore, general semaphore)는 음수 이외의 값으로 초기화 될 수 있고 다수의 프로세스의 임계영역으로의 진입을 허가할 수 있습니다.
- 뮤텍스(Mutex)는 락을 설정한 (값을 0으로 설정한) 프로세스만이 락을 해제할 수(값을 1로 재설정할 수) 있다는 것입니다.
- 반면 이진 세마포어의 경우 락을 설정한 프로세스와 해제하는 프로세스가 서로 다를 수 있습니다.
- 일부 문헌과 교재에서는 mutex와 binary semaphore에 대한 차이를 설명하지 않습니다. 하지만 Linux, Windows, Solaris 등의 운영체제에서 실제로 mutex는 위 설명대로 구현되어 있습니다.

>
- 참조
    - William, Stallings. 2015. Operating Systems: Internals and Design Principles. 8th Edition. Pearson Education.
